# {1} Introduction

{ This is work in progress to update OpenPGP.  Editorial notes are
  enclosed in curly braces.  The section numbers from RFC4880 are also
  indicated in curly braces. }

This document provides information on the message-exchange packet
formats used by OpenPGP to provide encryption, decryption, signing,
and key management functions.  It is a revision of RFC 2440, "OpenPGP
Message Format", which itself replaces RFC 1991, "PGP Message Exchange
Formats" [](#RFC1991) [](#RFC2440).

This document obsoletes: RFC 6637 (ECC for OpenPGP)


## {1.1} Terms

  * OpenPGP - This is a term for security software that uses PGP 5.x
    as a basis, formalized in RFC 2440 and this document.

  * PGP - Pretty Good Privacy.  PGP is a family of software systems
    developed by Philip R. Zimmermann from which OpenPGP is based.

"PGP", "Pretty Good", and "Pretty Good Privacy" are trademarks of PGP
Corporation and are used with permission.  The term "OpenPGP" refers to
the protocol described in this and related documents.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in [](#RFC2119).

# {3}  Data Element Formats

This section describes the data elements used by OpenPGP.

## {3.1} Scalar Numbers

Scalar numbers are unsigned and are always stored in big-endian
format.  Using n[k] to refer to the kth octet being interpreted, the
value of a two-octet scalar is ((n[0] \<\< 8) + n[1]).  The value of a
four-octet scalar is ((n[0] \<\< 24) + (n[1] \<\< 16) + (n[2] \<\< 8)
+ n[3]).

## {3.2} Multiprecision Integers

Multiprecision integers (also called MPIs) are unsigned integers used
to hold large integers such as the ones used in cryptographic
calculations.

An MPI consists of two pieces: a two-octet scalar that is the length
of the MPI in bits followed by a string of octets that contain the
actual integer.

These octets form a big-endian number; a big-endian number can be made
into an MPI by prefixing it with the appropriate length.

Examples:

(all numbers are in hexadecimal)

The string of octets [00 01 01] forms an MPI with the value 1.  The
string [00 09 01 FF] forms an MPI with the value of 511.

Additional rules:

The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.

The length field of an MPI describes the length starting from its most
significant non-zero bit.  Thus, the MPI [00 02 01] is not formed
correctly.  It should be [00 01 01].

Unused bits of an MPI MUST be zero.

Also note that when an MPI is encrypted, the length refers to the
plaintext MPI.  It may be ill-formed in its ciphertext.

## {3.3} Key IDs

A Key ID is an eight-octet scalar that identifies a
key.  Implementations SHOULD NOT assume that Key IDs are unique.  The
section "Enhanced Key Formats" below describes how Key IDs are formed.

## {3.4} Text

Unless otherwise specified, the character set for text is the UTF-8
[](#RFC3629) encoding of Unicode [](#ISO10646).

## {3.5} Time Fields

A time field is an unsigned four-octet number containing the number of
seconds elapsed since midnight, 1 January 1970 UTC.

## {3.6} Keyrings

A keyring is a collection of one or more keys in a file or database.
Traditionally, a keyring is simply a sequential list of keys, but may
be any suitable database.  It is beyond the scope of this standard to
discuss the details of keyrings or other databases.

## {3.7} String-to-Key (S2K) Specifiers

String-to-key (S2K) specifiers are used to convert passphrase strings
into symmetric-key encryption/decryption keys.  They are used in two
places, currently: to encrypt the secret part of private keys in the
private keyring, and to convert passphrases to encryption keys for
symmetrically encrypted messages.

### {3.7.1} String-to-Key (S2K) Specifier Types

There are three types of S2K specifiers currently supported, and some
reserved values:

          ID  S2K Type
  ----------  --------
           0  Simple S2K
           1  Salted S2K
           2  Reserved value
           3  Iterated and Salted S2K
  100 to 110  Private/Experimental S2K

These are described in the following Sections.

#### {3.7.1.1} Simple S2K

This directly hashes the string to produce the key data.  See below for
how this hashing is done.

       Octet 0:        0x00
       Octet 1:        hash algorithm

Simple S2K hashes the passphrase to produce the session key.  The
manner in which this is done depends on the size of the session key
(which will depend on the cipher used) and the size of the hash
algorithm's output.  If the hash size is greater than the session key
size, the high-order (leftmost) octets of the hash are used as the
key.

If the hash size is less than the key size, multiple instances of the
hash context are created -- enough to produce the required key data.
These instances are preloaded with 0, 1, 2, ... octets of zeros (that
is to say, the first instance has no preloading, the second gets
preloaded with 1 octet of zero, the third is preloaded with two octets
of zeros, and so forth).

As the data is hashed, it is given independently to each hash context.
Since the contexts have been initialized differently, they will each
produce different hash output.  Once the passphrase is hashed, the
output data from the multiple hashes is concatenated, first hash
leftmost, to produce the key data, with any excess octets on the right
discarded.

#### {3.7.1.2} Salted S2K

This includes a "salt" value in the S2K specifier -- some arbitrary
data -- that gets hashed along with the passphrase string, to help
prevent dictionary attacks.

       Octet 0:        0x01
       Octet 1:        hash algorithm
       Octets 2-9:     8-octet salt value

Salted S2K is exactly like Simple S2K, except that the input to the
hash function(s) consists of the 8 octets of salt from the S2K
specifier, followed by the passphrase.

#### {3.7.1.3} Iterated and Salted S2K

This includes both a salt and an octet count.  The salt is combined
with the passphrase and the resulting value is hashed repeatedly.  This
further increases the amount of work an attacker must do to try
dictionary attacks.

       Octet  0:        0x03
       Octet  1:        hash algorithm
       Octets 2-9:      8-octet salt value
       Octet  10:       count, a one-octet, coded value

The count is coded into a one-octet number using the following
formula:

       #define EXPBIAS 6
           count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);

The above formula is in C, where "Int32" is a type for a 32-bit
integer, and the variable "c" is the coded count, Octet 10.

Iterated-Salted S2K hashes the passphrase and salt data multiple
times.  The total number of octets to be hashed is specified in the
encoded count in the S2K specifier.  Note that the resulting count
value is an octet count of how many octets will be hashed, not an
iteration count.

Initially, one or more hash contexts are set up as with the other S2K
algorithms, depending on how many octets of key data are needed.  Then
the salt, followed by the passphrase data, is repeatedly hashed until
the number of octets specified by the octet count has been hashed.  The
one exception is that if the octet count is less than the size of the
salt plus passphrase, the full salt plus passphrase will be hashed
even though that is greater than the octet count.  After the hashing is
done, the data is unloaded from the hash context(s) as with the other
S2K algorithms.

### {3.7.2} String-to-Key Usage

Implementations SHOULD use salted or iterated-and-salted S2K
specifiers, as simple S2K specifiers are more vulnerable to dictionary
attacks.

#### {3.7.2.1} Secret-Key Encryption

An S2K specifier can be stored in the secret keyring to specify how to
convert the passphrase to a key that unlocks the secret data.

When an S2K specifier is used, the special value 253, 254, or 255 is
stored in the position where the hash algorithm octet would have been
in the old data structure.  This is then followed immediately by a
one-octet algorithm identifier, and then by the S2K specifier as
encoded above.

Therefore, preceding the secret data there will be one of these
possibilities:

       0:                 secret data is unencrypted (no passphrase)
       255, 254, or 253:  followed by algorithm octet and S2K specifier

These are followed by an Initial Vector of the same length as the
block size of the cipher for the decryption of the secret values, if
they are encrypted, and then the secret-key values themselves.

#### {3.7.2.2} Symmetric-Key Message Encryption

OpenPGP can create a Symmetric-key Encrypted Session Key (ESK) packet
at the front of a message.  This is used to allow S2K specifiers to be
used for the passphrase conversion or to create messages with a mix of
symmetric-key ESKs and public-key ESKs.  This allows a message to be
decrypted either with a passphrase or a public-key pair.

# {4}  Packet Syntax

This section describes the packets used by OpenPGP.

## {4.1} Overview

An OpenPGP message is constructed from a number of records that are
traditionally called packets. A packet is a chunk of data that has a
tag specifying its meaning.  An OpenPGP message, keyring, certificate,
and so forth consists of a number of packets.  Some of those packets
may contain other OpenPGP packets.

Each packet consists of a packet header, followed by the packet body.
The packet header is of variable length.

## {4.2} Packet Headers

The first octet of the packet header is called the "Packet Tag".  It
determines the format of the header and denotes the packet
contents.  The remainder of the packet header is the length of the
packet.

Note that the most significant bit is the leftmost bit, called bit
7. A mask for this bit is 0x80 in hexadecimal.

              +---------------+
         PTag |7 6 5 4 3 2 1 0|
              +---------------+
         Bit 7 -- Always one
         Bit 6 -- Always one
         Bits 5-0 -- packet tag

### {4.2.2} Packet Lengths

Packets have two possible ways of encoding length:

  3.  A five-octet Body Length header encodes packet lengths of up
      to 4,294,967,295 (0xFFFFFFFF) octets in length. (This actually
      encodes a four-octet scalar number.)

  4.  When the length of the packet body is not known in advance by
      the issuer, Partial Body Length headers encode a packet of
      indeterminate length, effectively making it a stream.

#### {4.2.2.3} Five-Octet Lengths

A five-octet Body Length header consists of a single octet holding the
value 255, followed by a four-octet scalar.  The body length is equal
to:

       bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |
                 (4th_octet << 8)  | 5th_octet

This basic set of one, two, and five-octet lengths is also used
internally to some packets.


#### {4.2.2.4} Partial Body Lengths

A Partial Body Length header is one octet long and encodes the length
of only part of the data packet.  This length is a power of 2, from 1
to 1,073,741,824 (2 to the 30th power).  It is recognized by its one
octet value that is greater than or equal to 224, and less than
255.  The Partial Body Length is equal to:

       partialBodyLen = 1 << (1st_octet & 0x1F);

Each Partial Body Length header is followed by a portion of the packet
body data.  The Partial Body Length header specifies this portion's
length.  Another length header (one octet, two-octet, five-octet, or
partial) follows that portion.  The last length header in the packet
MUST NOT be a Partial Body Length header.  Partial Body Length headers
may only be used for the non-final parts of the packet.

Note also that the last Body Length header can be a zero-length
header.

An implementation MAY use Partial Body Lengths for data packets, be
they literal, or encrypted.  The first partial length MUST
be at least 512 octets long.  Partial Body Lengths MUST NOT be used for
any other packet types.

### {4.2.3} Packet Length Examples

These examples show ways that new format packets might encode the
packet lengths.

A packet with length 100000 may have its length encoded in five
octets: 0xFF, 0x00, 0x01, 0x86, 0xA0.

It might also be encoded in the following octet stream: 0xEF, first
32768 octets of data; 0xE1, next two octets of data; 0xE0, next one
octet of data; 0xF0, next 65536 octets of data; 0xC5, 0xDD, last 1693
octets of data.  This is just one possible encoding, and many
variations are possible on the size of the Partial Body Length
headers, as long as a regular Body Length header encodes the last
portion of the data.

Please note that in all of these explanations, the total length of the
packet is the length of the header(s) plus the length of the body.

## {4.3} Packet Tags

The packet tag denotes what type of packet the body holds.  The
defined tags (in decimal) are as follows:

       Tag  Packet Type
  --------  --------------------------------------------------
         0  Reserved - a packet tag MUST NOT have this value
         1  Public-Key Encrypted Session Key Packet
         2  Signature Packet
         3  Symmetric-Key Encrypted Session Key Packet
         4  One-Pass Signature Packet
         5  Secret-Key Packet
         6  Public-Key Packet
         7  Secret-Subkey Packet
         8  Reserved
         9  Reserved
        10  Reserved (must be ignored)
        11  Literal Data Packet
        12  Reserved (must be ignored)
        13  User ID Packet
        14  Public-Subkey Packet
        17  Reserved
        18  Reserved
        19  Reserved
        20  AEAD Encrypted Data Packet
  60 to 63  Private or Experimental Values


# {5}  Packet Types

## {5.1}  Public-Key Encrypted Session Key Packets (Tag 1)

A Public-Key Encrypted Session Key packet holds the session key used
to encrypt a message.  Zero or more Public-Key Encrypted Session Key
packets and/or Symmetric-Key Encrypted Session Key packets may precede
an AEAD Encrypted Data Packet, which holds an encrypted
message.  The message is encrypted with the session key, and the
session key is itself encrypted and stored in the Encrypted Session
Key packet(s).  The AEAD Encrypted Data Packet is preceded by
one Public-Key Encrypted Session Key packet for each OpenPGP key to
which the message is encrypted.  The recipient of the message finds a
session key that is encrypted to their public key, decrypts the
session key, and then uses the session key to decrypt the message.

The body of this packet consists of:

  * A one-octet number giving the version number of the packet
    type.  The currently defined value for packet version is 3.

  * An eight-octet number that gives the Key ID of the public key to
    which the session key is encrypted.  If the session key is encrypted
    to a subkey, then the Key ID of this subkey is used here instead of
    the Key ID of the primary key.

  * A one-octet number giving the public-key algorithm used.

  * A string of octets that is the encrypted session key.  This string
    takes up the remainder of the packet, and its contents are dependent
    on the public-key algorithm used.

    Algorithm Specific Fields for RSA encryption:

      - Multiprecision integer (MPI) of RSA encrypted value m**e mod n.

    Algorithm-Specific Fields for ECDH encryption:

      - MPI of an EC point representing an ephemeral public key.

      - a one-octet size, followed by a symmetric key encoded using the
        method described in [](#ec-dh-algorithm-ecdh).

The value "m" in the above formulas is derived from the session key as
follows.  First, the session key is prefixed with a one-octet algorithm
identifier that specifies the symmetric encryption algorithm used to
encrypt the following AEAD Encrypted Data Packet.  Then a
two-octet checksum is appended, which is equal to the sum of the
preceding session key octets, not including the algorithm identifier,
modulo 65536.  This value is then encoded as described in PKCS\#1 block
encoding EME-PKCS1-v1\_5 in Section 7.2.1 of [](#RFC3447) to form the "m"
value used in the formulas above.  See Section 13.1 of this document
for notes on OpenPGP's use of PKCS\#1.

Note that when an implementation forms several PKESKs with one session
key, forming a message that can be decrypted by several keys, the
implementation MUST make a new PKCS\#1 encoding for each key.

An implementation MAY accept or use a Key ID of zero as a "wild card"
or "speculative" Key ID.  In this case, the receiving implementation
would try all available private keys, checking for a valid decrypted
session key.  This format helps reduce traffic analysis of messages.


## {5.2} Signature Packet (Tag 2)

A Signature packet describes a binding between some public key and
some data.  The most common signatures are a signature of a file or a
block of text, and a signature that is a certification of a User ID.

Version 4 provides an expandable format with subpackets that can
specify more information about the signature.

Implementations MUST generate V4 signatures.

### {5.2.1} Signature Types

There are a number of possible meanings for a signature, which are
indicated in a signature type octet in any given signature.  Please
note that the vagueness of these meanings is not a flaw, but a feature
of the system.  Because OpenPGP places final authority for validity
upon the receiver of a signature, it may be that one signer's casual
act might be more rigorous than some other authority's positive
act.  See Section 5.2.4, "Computing Signatures", for detailed
information on how to compute and verify signatures of each type.

These meanings are as follows:

0x00
  :   Signature of a binary document.  This means the signer owns it,
      created it, or certifies that it has not been modified.

0x01
  :   Signature of a canonical text document.  This means the
      signer owns it, created it, or certifies that it has not
      been modified.  The signature is calculated over the text
      data with its line endings converted to &lt;CR>&lt;LF>.

0x02
  :   Standalone signature.  This signature is a signature of only
      its own subpacket contents.  It is calculated identically to
      a signature over a zero-length binary document.

0x10
  :   Generic certification of a User ID and Public-Key
      packet.  The issuer of this certification does not make any
      particular assertion as to how well the certifier has
      checked that the owner of the key is in fact the person
      described by the User ID.

0x11
  :   Persona certification of a User ID and Public-Key
      packet.  The issuer of this certification has not done any
      verification of the claim that the owner of this key is the
      User ID specified.

0x12
  :   Casual certification of a User ID and Public-Key packet.  The
      issuer of this certification has done some casual
      verification of the claim of identity.

0x13
  :   Positive certification of a User ID and Public-Key packet.  The
      issuer of this certification has done substantial verification
      of the claim of identity.

      Most OpenPGP implementations make their "key signatures" as 0x10
      certifications.  Some implementations can issue 0x11-0x13
      certifications, but few differentiate between the types.

0x18
  :   Subkey Binding Signature This signature is a statement by
      the top-level signing key that indicates that it owns the
      subkey.  This signature is calculated directly on the primary
      key and subkey, and not on any User ID or other packets. A
      signature that binds a signing subkey MUST have an Embedded
      Signature subpacket in this binding signature that contains
      a 0x19 signature made by the signing subkey on the primary
      key and subkey.

0x19
  :   Primary Key Binding Signature This signature is a statement
      by a signing subkey, indicating that it is owned by the
      primary key and subkey.  This signature is calculated the
      same way as a 0x18 signature: directly on the primary key
      and subkey, and not on any User ID or other packets.

0x1F
  :   Signature directly on a key This signature is calculated
      directly on a key.  It binds the information in the Signature
      subpackets to the key, and is appropriate to be used for
      subpackets that provide information about the key, such as
      the Revocation Key subpacket.  It is also appropriate for
      statements that non-self certifiers want to make about the
      key itself, rather than the binding between a key and a
      name.

0x20
  :   Key revocation signature The signature is calculated
      directly on the key being revoked. A revoked key is not to
      be used.  Only revocation signatures by the key being
      revoked, or by an authorized revocation key, should be
      considered valid revocation signatures.

0x28
  :   Subkey revocation signature The signature is calculated
      directly on the subkey being revoked. A revoked subkey is
      not to be used.  Only revocation signatures by the top-level
      signature key that is bound to this subkey, or by an
      authorized revocation key, should be considered valid
      revocation signatures.

0x30
  :   Certification revocation signature This signature revokes an
      earlier User ID certification signature (signature class
      0x10 through 0x13) or direct-key signature (0x1F).  It should
      be issued by the same key that issued the revoked signature
      or an authorized revocation key.  The signature is computed
      over the same data as the certificate that it revokes, and
      should have a later creation date than that certificate.

0x40
  :   Timestamp signature.  This signature is only meaningful for
      the timestamp contained in it.

0x50
  :   Third-Party Confirmation signature.  This signature is a
      signature over some other OpenPGP Signature packet(s).  It is
      analogous to a notary seal on the signed data. A third-party
      signature SHOULD include Signature Target subpacket(s) to
      give easy identification.  Note that we really do mean
      SHOULD.  There are plausible uses for this (such as a blind
      party that only sees the signature, not the key or source
      document) that cannot include a target subpacket.


### {5.2.3} Version 4 Signature Packet Format

The body of a version 4 Signature packet contains:

  * One-octet version number (4).

  * One-octet signature type.

  * One-octet public-key algorithm.

  * One-octet hash algorithm.

  * Two-octet scalar octet count for following hashed subpacket
    data.  Note that this is the length in octets of all of the
    hashed subpackets; a pointer incremented by this number will
    skip over the hashed subpackets.

  * Hashed subpacket data set (zero or more subpackets).

  * Two-octet scalar octet count for the following unhashed
    subpacket data.  Note that this is the length in octets of all
    of the unhashed subpackets; a pointer incremented by this
    number will skip over the unhashed subpackets.

  * Unhashed subpacket data set (zero or more subpackets).

  * Two-octet field holding the number 00 00.

  * One or more multiprecision integers comprising the signature.
    This portion is algorithm specific:

    Algorithm-Specific Fields for RSA signatures:

      * Multiprecision integer (MPI) of RSA signature value m**d mod n.

    Algorithm-Specific Fields for EdDSA signatures:

      * MPI of EdDSA compressed value r.

      * MPI of EdDSA compressed value s.

The compressed version of R and S for use with EdDSA is described in
[](#I-D.irtf-cfrg-eddsa).

The concatenation of the data being signed and the signature data from
the version number through the hashed subpacket data (inclusive) is
hashed.  The resulting hash value is what is signed.

There are two fields consisting of Signature subpackets.  The first
field is hashed with the rest of the signature data, while the second
is unhashed.  The second set of subpackets is not cryptographically
protected by the signature and should include only advisory
information.

The algorithms for converting the hash function result to a signature
are described in a section below.

#### {5.2.3.1} Signature Subpacket Specification

A subpacket data set consists of zero or more Signature subpackets.  In
Signature packets, the subpacket data set is preceded by a two- octet
scalar count of the length in octets of all the subpackets. A pointer
incremented by this number will skip over the subpacket data set.

Each subpacket consists of a subpacket header and a body.  The header
consists of:

  * The octet 0xFF.

  * the subpacket length (4 octets),

  * the subpacket type (1 octet),

and is followed by the subpacket-specific data.

The length includes the type octet but not the initial octet or the
length octets.

The value of the subpacket type octet may be:

        Type   Description
  ----------   ---------------------------------------
           0   Reserved
           1   Reserved
           2   Signature Creation Time
           3   Signature Expiration Time
           4   Reserved
           5   Reserved
           6   Reserved
           7   Revocable
           8   Reserved
           9   Key Expiration Time
          10   Placeholder for backward compatibility
          11   Reserved
          12   Revocation Key
    13 to 15   Reserved
          16   Reserved
    17 to 19   Reserved
          20   Reserved
          21   Preferred Hash Algorithms
          22   Reserved
          23   Reserved
          24   Reserved
          25   Primary User ID
          26   Reserved
          27   Key Flags
          28   Signer's User ID
          29   Reason for Revocation
          30   Reserved
          31   Signature Target
          32   Embedded Signature
          33   Issuer Fingerprint
          34   Reserved
  100 to 110   Private or experimental

An implementation SHOULD ignore any subpacket of a type that it does
not recognize.

Bit 7 of the subpacket type is the "critical" bit.  If set, it denotes
that the subpacket is one that is critical for the evaluator of the
signature to recognize.  If a subpacket is encountered that is marked
critical but is unknown to the evaluating software, the evaluator
SHOULD consider the signature to be in error.

An evaluator may "recognize" a subpacket, but not implement it.  The
purpose of the critical bit is to allow the signer to tell an
evaluator that it would prefer a new, unknown feature to generate an
error than be ignored.

Implementations SHOULD implement the four preferred algorithm
subpackets (11, 21, 22, and 34), as well as the "Reason for Revocation"
subpacket.  Note, however, that if an implementation chooses not to
implement some of the preferences, it is required to behave in a
polite manner to respect the wishes of those users who do implement
these preferences.

#### {5.2.3.2} Signature Subpacket Types

A number of subpackets are currently defined.  Some subpackets apply to
the signature itself and some are attributes of the key.  Subpackets
that are found on a self-signature are placed on a certification made
by the key itself.  Note that a key may have more than one User ID, and
thus may have more than one self-signature, and differing subpackets.

A subpacket may be found either in the hashed or unhashed subpacket
sections of a signature.  If a subpacket is not hashed, then the
information in it cannot be considered definitive because it is not
part of the signature proper.

#### {5.2.3.3} Notes on Self-Signatures

A self-signature is a binding signature made by the key to which the
signature refers.  There are three types of self-signatures, the
certification signatures (types 0x10-0x13), the direct-key signature
(type 0x1F), and the subkey binding signature (type 0x18).  For
certification self-signatures, each User ID may have a self-
signature, and thus different subpackets in those self-signatures.  For
subkey binding signatures, each subkey in fact has a self- signature.
Subpackets that appear in a certification self-signature apply to the
user name, and subpackets that appear in the subkey self-signature
apply to the subkey.  Lastly, subpackets on the direct-key signature
apply to the entire key.

Revoking a self-signature or allowing it to expire has a semantic
meaning that varies with the signature type.  Revoking the self-
signature on a User ID effectively retires that user name.  The
self-signature is a statement, "My name X is tied to my signing key K"
and is corroborated by other users' certifications.  If another user
revokes their certification, they are effectively saying that they no
longer believe that name and that key are tied together.  Similarly, if
the users themselves revoke their self-signature, then the users no
longer go by that name, no longer have that email address,
etc.  Revoking a binding signature effectively retires that
subkey.  Revoking a direct-key signature cancels that signature.  Please
see the "Reason for Revocation" subpacket (Section 5.2.3.23) for more
relevant detail.

Since a self-signature contains important information about the key's
use, an implementation SHOULD allow the user to rewrite the
self-signature, and important information in it, such as preferences
and key expiration.

An implementation that encounters multiple self-signatures on the same
object may resolve the ambiguity in any way it sees fit, but it is
RECOMMENDED that priority be given to the most recent self-signature.


#### {5.2.3.4} Signature Creation Time

(4-octet time field)

The time the signature was made.

MUST be present in the hashed area.

#### {5.2.3.6} Key Expiration Time

(4-octet time field)

The validity period of the key.  This is the number of seconds after
the key creation time that the key expires.  If this is not present or
has a value of zero, the key never expires.  This is found only on a
self-signature.

#### {5.2.3.8} Preferred Hash Algorithms

(array of one-octet values)

Message digest algorithm numbers that indicate which algorithms the
key holder prefers to receive.  Like the preferred symmetric
algorithms, the list is ordered.  Algorithm numbers are in Section
9.  This is only found on a self-signature.

#### {5.2.3.10} Signature Expiration Time

(4-octet time field)

The validity period of the signature.  This is the number of seconds
after the signature creation time that the signature expires.  If this
is not present or has a value of zero, it never expires.

#### {5.2.3.12} Revocable

(1 octet of revocability, 0 for not, 1 for revocable)

Signature's revocability status.  The packet body contains a Boolean
flag indicating whether the signature is revocable.  Signatures that
are not revocable have any later revocation signatures ignored.  They
represent a commitment by the signer that he cannot revoke his
signature for the life of his key.  If this packet is not present, the
signature is revocable.

#### {5.2.3.15} Revocation Key

(1 octet of class, 1 octet of public-key algorithm ID, 32 octets of
fingerprint)

V5 keys use the full 32 octet fingerprint.

Authorizes the specified key to issue revocation signatures for this
key.  Class octet must have bit 0x80 set.  If the bit 0x40 is set, then
this means that the revocation information is sensitive.  Other bits
are for future expansion to other kinds of authorizations.  This is
found on a self-signature.

If the "sensitive" flag is set, the keyholder feels this subpacket
contains private trust information that describes a real-world
sensitive relationship.  If this flag is set, implementations SHOULD
NOT export this signature to other users except in cases where the
data needs to be available: when the signature is being sent to the
designated revoker, or when it is accompanied by a revocation
signature from that revoker.  Note that it may be appropriate to
isolate this subpacket within a separate signature so that it is not
combined with other subpackets that need to be exported.

#### {5.2.3.19} Primary User ID

(1 octet, Boolean)

This is a flag in a User ID's self-signature that states whether this
User ID is the main User ID for this key.  It is reasonable for an
implementation to resolve ambiguities in preferences, etc. by
referring to the primary User ID.  If this flag is absent, its value is
zero.  If more than one User ID in a key is marked as primary, the
implementation may resolve the ambiguity in any way it sees fit, but
it is RECOMMENDED that priority be given to the User ID with the most
recent self-signature.

When appearing on a self-signature on a User ID packet, this subpacket
applies only to User ID packets.

#### {5.2.3.21} Key Flags

(N octets of flags)

This subpacket contains a list of binary flags that hold information
about a key.  It is a string of octets, and an implementation MUST NOT
assume a fixed size.  This is so it can grow over time.  If a list is
shorter than an implementation expects, the unstated flags are
considered to be zero.  The defined flags are as follows:

0x01
  :  This key may be used to certify other keys.

0x02
  :  This key may be used to sign data.

0x04
  :  This key may be used to encrypt communications.

0x08
  :  This key may be used to encrypt storage.

0x10
  :  The private component of this key may have
               been split by a secret-sharing mechanism.
0x20
  :  This key may be used for authentication.

0x80
  :  The private component of this key may be in the
     possession of more than one person.

Usage notes:

The flags in this packet may appear in self-signatures or in
certification signatures.  They mean different things depending on who
is making the statement --- for example, a certification signature that
has the "sign data" flag is stating that the certification is for that
use.  On the other hand, the "communications encryption" flag in a
self-signature is stating a preference that a given key be used for
communications.  Note however, that it is a thorny issue to determine
what is "communications" and what is "storage".  This decision is left
wholly up to the implementation; the authors of this document do not
claim any special wisdom on the issue and realize that accepted
opinion may change.

The "split key" (0x10) and "group key" (0x80) flags are placed on a
self-signature only; they are meaningless on a certification
signature.  They SHOULD be placed only on a direct-key signature (type
0x1F) or a subkey signature (type 0x18), one that refers to the key
the flag applies to.

#### {5.2.3.22} Signer's User ID

(String)

This subpacket allows a keyholder to state which User ID is
responsible for the signing.  Many keyholders use a single key for
different purposes, such as business communications as well as
personal communications.  This subpacket allows such a keyholder to
state which of their roles is making a signature.

#### {5.2.3.23} Reason for Revocation

(1 octet of revocation code, N octets of reason string)

This subpacket is used only in key revocation and certification
revocation signatures.  It describes the reason why the key or
certificate was revoked.

The first octet contains a machine-readable code that denotes the
reason for the revocation:

     Code  Reason
  -------  ---------------------------------------------------------
        0  No reason specified (key revocations or cert revocations)
        1  Key is superseded (key revocations)
        2  Key material has been compromised (key revocations)
        3  Key is retired and no longer used (key revocations)
       32  User ID information is no longer valid (cert revocations)
  100-110  Private Use

Following the revocation code is a string of octets that gives
information about the Reason for Revocation in human-readable form
(UTF-8).  The string may be null, that is, of zero length.  The length
of the subpacket is the length of the reason string plus one.  An
implementation SHOULD implement this subpacket, include it in all
revocation signatures, and interpret revocations appropriately.  There
are important semantic differences between the reasons, and there are
thus important reasons for revoking signatures.

If a key has been revoked because of a compromise, all signatures
created by that key are suspect.  However, if it was merely superseded
or retired, old signatures are still valid.  If the revoked signature
is the self-signature for certifying a User ID, a revocation denotes
that that user name is no longer in use.  Such a revocation SHOULD
include a 0x20 code.

Note that any signature may be revoked, including a certification on
some other person's key.  There are many good reasons for revoking a
certification signature, such as the case where the keyholder leaves
the employ of a business with an email address. A revoked
certification is no longer a part of validity calculations.

#### {5.2.3.25} Signature Target

(1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)

This subpacket identifies a specific target signature to which a
signature refers.  For revocation signatures, this subpacket provides
explicit designation of which signature is being revoked.  For a
third-party or timestamp signature, this designates what signature is
signed.  All arguments are an identifier of that target signature.

The N octets of hash data MUST be the size of the hash of the
signature.  For example, a target signature with a SHA2-256 hash MUST
have 32 octets of hash data.

#### {5.2.3.26} Embedded Signature

(1 signature packet body)

This subpacket contains a complete Signature packet body as specified
in Section 5.2 above.  It is useful when one signature needs to refer
to, or be incorporated in, another signature.

#### Issuer Fingerprint

(1 octet key version number, N octets of fingerprint)

The OpenPGP Key fingerprint of the key issuing the signature.  This
subpacket SHOULD be included in all signatures.

Note that the length N of the fingerprint for a version 5 key N is 32.


### {5.2.4} Computing Signatures

All signatures are formed by producing a hash over the signature data,
and then using the resulting hash in the signature algorithm.

For binary document signatures (type 0x00), the document data is
hashed directly.  For text document signatures (type 0x01), the
document is canonicalized by converting line endings to &lt;CR>&lt;LF>, and
the resulting data is hashed.

When a signature is made over a key, the hash data starts with the
octet 0x99, followed by a two-octet length of the key, and then body
of the key packet. (Note that this is an old-style packet header for a
key packet with two-octet length.) A subkey binding signature (type
0x18) or primary key binding signature (type 0x19) then hashes the
subkey using the same format as the main key (also using 0x99 as the
first octet).  Primary key revocation signatures (type 0x20) hash only
the key being revoked.  Subkey revocation signature (type 0x28) hash
first the primary key and then the subkey being revoked.

A certification signature (type 0x10 through 0x13) hashes the User ID
being bound to the key into the hash context after the above data. A
V4 or V5 certification hashes the constant 0xB4 for User ID
certifications, followed by a four-octet number giving the length of
the User ID, and then the User ID data

When a signature is made over a Signature packet (type 0x50), the hash
data starts with the octet 0x88, followed by the four-octet length of
the signature, and then the body of the Signature packet. (Note that
this is an old-style packet header for a Signature packet with the
length-of-length set to zero.) The unhashed subpacket data of the
Signature packet being hashed is not included in the hash, and the
unhashed subpacket data length value is set to zero.

Once the data body is hashed, then a trailer is hashed. A V4 or V5
signature hashes the packet body starting from its first field, the
version number, through the end of the hashed subpacket data.  Thus,
the fields hashed are the signature version, the signature type, the
public-key algorithm, the hash algorithm, the hashed subpacket length,
and the hashed subpacket body.

V4 signatures also hash in a final trailer of six octets: the version
of the Signature packet, i.e., 0x04; 0xFF; and a four-octet,
big-endian number that is the length of the hashed data from the
Signature packet (note that this number does not include these final
six octets).  {FIXME: truncated or wrap that number on overflow}

V5 signatures instead hash in a ten-octet trailer: the version of the
Signature packet, i.e., 0x05; 0xFF; and an eight-octet, big-endian
number that is the length of the hashed data from the Signature packet
(note that this number does not include these final ten octets).

After all this has been hashed in a single hash context, the resulting
hash field is used in the signature algorithm and placed at the end of
the Signature packet.

#### {5.2.4.1} Subpacket Hints

It is certainly possible for a signature to contain conflicting
information in subpackets.  For example, a signature may contain
multiple copies of a preference or multiple expiration times.  In most
cases, an implementation SHOULD use the last subpacket in the
signature, but MAY use any conflict resolution scheme that makes more
sense.  Please note that we are intentionally leaving conflict
resolution to the implementer; most conflicts are simply syntax
errors, and the wishy-washy language here allows a receiver to be
generous in what they accept, while putting pressure on a creator to
be stingy in what they generate.

## {5.3} Symmetric-Key Encrypted Session Key Packets (Tag 3)

The Symmetric-Key Encrypted Session Key packet holds the symmetric-key
encryption of a session key used to encrypt a message.  Zero or more
Public-Key Encrypted Session Key packets and/or Symmetric-Key
Encrypted Session Key packets may precede a Symmetrically Encrypted
Data packet that holds an encrypted message.  The message is encrypted
with a session key, and the session key is itself encrypted and stored
in the Encrypted Session Key packet or the Symmetric-Key Encrypted
Session Key packet.

If the Symmetrically Encrypted Data packet is preceded by one or more
Symmetric-Key Encrypted Session Key packets, each specifies a
passphrase that may be used to decrypt the message.  This allows a
message to be encrypted to a number of public keys, and also to one or
more passphrases.

A version 4 Symmetric-Key Encrypted Session Key packet consists of:

  * A one-octet version number with value 4.

  * A one-octet number describing the symmetric algorithm used.

  * A string-to-key (S2K) specifier, length as defined above.

  * Optionally, the encrypted session key itself, which is
    decrypted with the string-to-key object.

If the encrypted session key is not present (which can be detected on
the basis of packet length and S2K specifier size), then the S2K
algorithm applied to the passphrase produces the session key for
decrypting the file, using the symmetric cipher algorithm from the
Symmetric-Key Encrypted Session Key packet.

If the encrypted session key is present, the result of applying the
S2K algorithm to the passphrase is used to decrypt just that encrypted
session key field, using CFB mode with an IV of all zeros.  The
decryption result consists of a one-octet algorithm identifier that
specifies the symmetric-key encryption algorithm used to encrypt the
following Symmetrically Encrypted Data packet, followed by the session
key octets themselves.

Note: because an all-zero IV is used for this decryption, the S2K
specifier MUST use a salt value, either a Salted S2K or an
Iterated-Salted S2K.  The salt value will ensure that the decryption
key is not repeated even if the passphrase is reused.

A version 5 Symmetric-Key Encrypted Session Key packet consists of:

  * A one-octet version number with value 5.

  * A one-octet cipher algorithm.

  * A one-octet AEAD algorithm.

  * A string-to-key (S2K) specifier, length as defined above.

  * A starting initialization vector of size specified by the AEAD
    algorithm.

  * The encrypted session key itself, which is decrypted with the
    string-to-key object using the given cipher and AEAD mode.

  * A final, summary authentication tag for the AEAD mode.

The encrypted session key is encrypted exactly as an AEAD Encrypted Data
packet with a chunk size octet of 10 would be.  This implicit chunk size
octet is included in the normal calculations of additional data.

## {5.4} One-Pass Signature Packets (Tag 4)

The One-Pass Signature packet precedes the signed data and contains
enough information to allow the receiver to begin calculating any
hashes needed to verify the signature.  It allows the Signature packet
to be placed at the end of the message, so that the signer can compute
the entire signed message in one pass.

The body of this packet consists of:

* A one-octet version number.  The current version is 3.

* A one-octet signature type.  Signature types are described in
  [](#signature-types).

* A one-octet number describing the hash algorithm used.

* A one-octet number describing the public-key algorithm used.

* An eight-octet number holding the Key ID of the signing key.

* A one-octet number holding a flag showing whether the signature
  is nested.  A zero value indicates that the next packet is
  another One-Pass Signature packet that describes another
  signature to be applied to the same message data.

Note that if a message contains more than one one-pass signature, then
the Signature packets bracket the message; that is, the first
Signature packet after the message corresponds to the last one-pass
packet and the final Signature packet corresponds to the first
one-pass packet.

## {5.5} Key Material Packet

A key material packet contains all the information about a public or
private key.  There are four variants of this packet type, and two
major versions.  Consequently, this section is complex.

### {5.5.1} Key Packet Variants

#### {5.5.1.1} Public-Key Packet (Tag 6)

A Public-Key packet starts a series of packets that forms an OpenPGP
key (sometimes called an OpenPGP certificate).

#### {5.5.1.2} Public-Subkey Packet (Tag 14)

A Public-Subkey packet (tag 14) has exactly the same format as a
Public-Key packet, but denotes a subkey.  One or more subkeys may be
associated with a top-level key.  By convention, the top-level key
provides signature services, and the subkeys provide encryption
services.

#### {5.5.1.3} Secret-Key Packet (Tag 5)

A Secret-Key packet contains all the information that is found in a
Public-Key packet, including the public-key material, but also
includes the secret-key material after all the public-key fields.

#### {5.5.1.4} Secret-Subkey Packet (Tag 7)

A Secret-Subkey packet (tag 7) is the subkey analog of the Secret Key
packet and has exactly the same format.

### {5.5.2} Public-Key Packet Formats

A version 5 packet contains:

  * A one-octet version number (5).

  * A four-octet number denoting the time that the key was created.

  * A one-octet number denoting the public-key algorithm of this
    key.

  * A four-octet scalar octet count for the following key material.

  * A series of values comprising the key material.  This is
    algorithm-specific and described in section XXXX.


### {5.5.3} Secret-Key Packet Formats

The Secret-Key and Secret-Subkey packets contain all the data of the
Public-Key and Public-Subkey packets, with additional algorithm-
specific secret-key data appended, usually in encrypted form.

The packet contains:

  * A Public-Key or Public-Subkey packet, as described above.

  * One octet indicating string-to-key usage conventions.  Zero
    indicates that the secret-key data is not encrypted.  255 or
    254 indicates that a string-to-key specifier is being given.
    Any other value is a symmetric-key encryption algorithm
    identifier.  A version 5 packet MUST NOT use the value 255.

  * Only for a version 5 packet, a one-octet scalar octet count of the
    next 3 optional fields.

  * [Optional] If string-to-key usage octet was 255, 254, or 253, a one-
    octet symmetric encryption algorithm.

  * [Optional] If string-to-key usage octet was 253, a one-octet AEAD
    algorithm.

  * [Optional] If string-to-key usage octet was 255, 254, or 253, a
    string-to-key specifier.  The length of the string-to-key
    specifier is implied by its type, as described above.

  * [Optional] If secret data is encrypted (string-to-key usage
    octet not zero), an Initial Vector (IV) of the same length as
    the cipher's block size.

  * Only for a version 5 packet, a four-octet scalar octet count for
    the following key material.

  * Plain or encrypted series of values comprising the secret key
    material.  This is algorithm-specific and described in section
    XXXX.

  * If the string-to-key usage octet is zero or 255, then a
    two-octet checksum of the plaintext of the algorithm-specific
    portion (sum of all octets, mod 65536).  If the string-to-key
    usage octet was 254, then a 20-octet SHA-1 hash of the
    plaintext of the algorithm-specific portion.  This checksum or
    hash is encrypted together with the algorithm-specific fields
    (if string-to-key usage octet is not zero).  If the string-to-key
    usage octet was 253, then an AEAD authentication tag is included
    here.  Note that for all other values, a two-octet checksum is
    required.

Note that the version 5 packet format adds two count values
to help parsing packets with unknown S2K or public key algorithms.

Secret MPI values can be encrypted using a passphrase.  A string-
to-key specifier MUST be given that describes the algorithm for
converting the passphrase to a key.  The cipher for encrypting the
MPIs is specified in the Secret-Key packet.

Encryption/decryption of the secret data is done in CFB mode using the
key created from the passphrase and the Initial Vector from the
packet. With V5 keys, all secret MPI values are encrypted, including
the MPI bitcount prefix.

If the string-to-key usage octet is 253, the encrypted MPI values are
encrypted as one combined plaintext exactly as an AEAD Encrypted Data
packet with a chunk size octet of 10 would be.  This implicit chunk size
octet is included in the normal calculations of additional data.

The two-octet checksum that follows the algorithm-specific portion is
the algebraic sum, mod 65536, of the plaintext of all the algorithm-
specific octets (including MPI prefix and data). This checksum
is deprecated; an implementation SHOULD NOT use it, but should rather
use the SHA-1 hash denoted with a usage octet of 254.


## Algorithm-specific Parts of Keys

The public and secret key format specifies algorithm-specific parts
of a key.  The following sections describe them in detail.

### Algorithm-Specific Part for RSA Keys

The public key is this series of multiprecision integers:

  * MPI of RSA public modulus n;

  * MPI of RSA public encryption exponent e.

The secret key is this series of multiprecision integers:

  * MPI of RSA secret exponent d;

  * MPI of RSA secret prime value p;

  * MPI of RSA secret prime value q (p < q);

  * MPI of u, the multiplicative inverse of p, mod q.


### Algorithm-Specific Part for EdDSA Keys

The public key is this series of values:

  * a variable-length field containing a curve OID, formatted
    as follows:

      - a one-octet size of the following field; values 0 and
        0xFF are reserved for future extensions,

      - the octets representing a curve OID, defined in
        section NN{FIXME};

  * a MPI of an EC point representing a public key Q as described
    under EdDSA Point Format below.

The secret key is this single multiprecision integer:

  * MPI of an integer representing the secret key, which is a
    scalar of the public EC point.


### Algorithm-Specific Part for ECDH Keys

The public key is this series of values:

  * a variable-length field containing a curve OID, formatted
    as follows:

      - a one-octet size of the following field; values 0 and
        0xFF are reserved for future extensions,

      - the octets representing a curve OID, defined in
        Section 11{FIXME};

  * a MPI of an EC point representing a public key;

  * a variable-length field containing KDF parameters,
    formatted as follows:

      - a one-octet size of the following fields; values 0
        and 0xff are reserved for future extensions;

      - a one-octet value 1, reserved for future extensions;

      - a one-octet hash function ID used with a KDF;

      - a one-octet algorithm ID for the symmetric algorithm
        used to wrap the symmetric key used for the message
        encryption; see Section 8 for details.

The secret key is this single multiprecision integer:

  * MPI of an integer representing the secret key, which is a
    scalar of the public EC point.

## {5.9} Literal Data Packet (Tag 11)

A Literal Data packet contains the body of a message; data that is not
to be further interpreted.

The body of this packet consists of:

  * Octets 0x62 0x00 0x00 0x00 0x00 0x00.

  * The remainder of the packet is literal data.

## {5.11} User ID Packet (Tag 13)

A User ID packet consists of UTF-8 text that is intended to represent
the name and email address of the key holder.  By convention, it
includes an RFC 2822 [](#RFC2822) mail name-addr, but there are no
restrictions on its content.  The packet length in the header specifies
the length of the User ID.

## AEAD Encrypted Data Packet (Tag 20)

This packet contains data encrypted with an authenticated encryption and
additional data (AEAD) construction.  When it has been decrypted, it
will typically contain other packets (often a Literal Data packet).

The body of this packet consists of:

  * A one-octet version number.  The only currently defined value
    is 1.

  * A one-octet cipher algorithm.

  * A one-octet AEAD algorithm.

  * A one-octet chunk size.

  * A starting initialization vector of size specified by the AEAD
    algorithm.

  * Encrypted data, the output of the selected symmetric-key cipher
    operating in the given AEAD mode.

  * A final, summary authentication tag for the AEAD mode.

An AEAD encrypted data packet consists of one or more chunks of data.
The plaintext of each chunk is of a size specified using the chunk size
octet using the method specified below.

The encrypted data consists of the encryption of each chunk of
plaintext, followed immediately by the relevant authentication tag.  If
the last chunk of plaintext is smaller than the chunk size, the
ciphertext for that data may be shorter; it is nevertheless followed by
a full authentication tag.

For each chunk, the AEAD construction is given the packet header,
version number, cipher algorithm octet, AEAD algorithm octet, chunk size
octet, and an eight-octet, big-endian chunk index as additional
data.  The index of the first chunk is zero.

After the final chunk, the AEAD algorithm is used to produce a final
authentication tag encrypting the empty string.  This AEAD instance is
given the additional data specified above, plus an eight-octet,
big-endian value specifying the total number of plaintext octets
encrypted.  This allows detection of a truncated ciphertext.

The chunk size octet specifies the size of chunks using the following
formula (in C), where c is the chunk size octet:

        chunk_size = ((uint64_t)1 << (c + 6))

An implementation MUST support chunk size octets with values from 0 to
56.  Chunk size octets with other values are reserved for future
extensions.

A new random initialization vector MUST be used for each message.

### EAX Mode

The EAX algorithm can only use block ciphers with 16-octet
blocks.  The starting initialization vector and authentication tag are
both 16 octets long.

The starting initialization vector for this mode MUST be unique and
unpredictable.

The nonce for EAX mode is computed by treating the starting
initialization vector as a 16-octet, big-endian value and
exclusive-oring the low eight octets of it with the chunk index.

The security of EAX requires that the nonce is never reused, hence the
requirement that the starting initialization vector be unique.

# {9}  Constants

This section describes the constants used in OpenPGP.

Note that these tables are not exhaustive lists; an implementation MAY
implement an algorithm not on these lists, so long as the algorithm
numbers are chosen from the private or experimental algorithm range.

See the section "Notes on Algorithms" below for more discussion of the
algorithms.

## {9.1} Public-Key Algorithms

       ID  Algorithm
 --------  ---------
        1  RSA (Encrypt or Sign) [](#HAC)
        2  Reserved
        3  Reserved
       16  Reserved
       17  Reserved
       18  ECDH public key algorithm
       19  Reserved
       20  Reserved
       21  Reserved
       22  EdDSA  [](#I-D.irtf-cfrg-eddsa)
 100--110  Private/Experimental algorithm

Implementations MUST implement EdDSA for signatures, and ECDH for
encryption.  Implementations SHOULD implement RSA keys (1).

## ECC Curve OID

The parameter curve OID is an array of octets that define a named
curve.  The table below specifies the exact sequence of bytes for each
named curve referenced in this document:

  ------------           --- -----------------------        -------------
  ASN.1 Object           OID Curve OID bytes in             Curve name
  Identifier             len hexadecimal
                             representation
  ------------           --- -----------------------        -------------
  1.3.6.1.4.1.11591.15.1  9  2B 06 01 04 01 DA 47 0F 01     Ed25519

  1.3.6.1.4.1.3029.1.5.1  10 2B 06 01 04 01 97 55 01 05 01  Curve25519
  -----------------------------------------------------------------------

The sequence of octets in the third column is the result of applying
the Distinguished Encoding Rules (DER) to the ASN.1 Object Identifier
with subsequent truncation.  The truncation removes the two fields of
encoded Object Identifier.  The first omitted field is one octet
representing the Object Identifier tag, and the second omitted field
is the length of the Object Identifier body.  For example, the
complete ASN.1 DER encoding for the Ed25519 curve OID is "06 01 04
01 DA 47 0F 01", from which the first entry in the table above
is constructed by omitting the first two octets.  Only the truncated
sequence of octets is the valid representation of a curve OID.


## {9.2} Symmetric-Key Algorithms


       ID  Algorithm
 --------  ---------
        0  Reserved
        1  Reserved
        2  Reserved
        3  Reserved
        4  Reserved
        5  Reserved
        6  Reserved
        7  Reserved
        8  Reserved
        9  AES with 256-bit key
       10  Reserved
       11  Reserved
       12  Reserved
       13  Reserved
 100--110  Private/Experimental algorithm

Implementations MUST implement AES-256.

## {9.4} Hash Algorithms

       ID  Algorithm                        Text Name
 --------  ---------                        ---------
        1  Reserved
        2  SHA-1 [](#FIPS180)               "SHA1"
        3  Reserved
        4  Reserved
        5  Reserved
        6  Reserved
        7  Reserved
        8  SHA2-256 [](#FIPS180)             "SHA256"
        9  Reserved
       10  Reserved
       11  Reserved
       12  Reserved
       13  Reserved
       14  Reserved
 100--110  Private/Experimental algorithm

Implementations MUST implement SHA2-256.

## AEAD Algorithms

       ID  Algorithm
 --------  ---------
        1  EAX [](#EAX)
        2  Reserved
 100--110  Private/Experimental algorithm

Implementations MUST implement EAX.

# {11} Packet Composition

OpenPGP packets are assembled into sequences in order to create
messages and to transfer keys.  Not all possible packet sequences are
meaningful and correct.  This section describes the rules for how
packets should be placed into sequences.

## {11.1} Transferable Public Keys

OpenPGP users may transfer public keys.  The essential elements of a
transferable public key are as follows:

  - One Public-Key packet

  - Zero or more revocation signatures

  - Zero or more User ID packets

  - After each User ID packet, zero or more Signature packets
    (certifications)

  - Zero or more Subkey packets

  - After each Subkey packet, one Signature packet, plus optionally a
    revocation

The Public-Key packet occurs first.  Each of the following User ID
packets provides the identity of the owner of this public key.  If
there are multiple User ID packets, this corresponds to multiple means
of identifying the same unique individual user; for example, a user
may have more than one email address, and construct a User ID for each
one.

Immediately following each User ID packet, there are zero or more
Signature packets.  Each Signature packet is calculated on the
immediately preceding User ID packet and the initial Public-Key
packet.  The signature serves to certify the corresponding public key
and User ID.  In effect, the signer is testifying to his or her belief
that this public key belongs to the user identified by this User ID.

After the User ID packet, there may be zero or more Subkey packets.
In general, subkeys are provided in cases where the top-level public
key is a signature-only key.  However, any V5 key may have subkeys,
and the subkeys may be encryption-only keys, signature-only keys, or
general-purpose keys.

Each Subkey packet MUST be followed by one Signature packet, which
should be a subkey binding signature issued by the top-level key.  For
subkeys that can issue signatures, the subkey binding signature MUST
contain an Embedded Signature subpacket with a primary key binding
signature (0x19) issued by the subkey on the top-level key.

Subkey and Key packets may each be followed by a revocation Signature
packet to indicate that the key is revoked.  Revocation signatures are
only accepted if they are issued by the key itself, or by a key that
is authorized to issue revocations via a Revocation Key subpacket in a
self-signature by the top-level key.

Transferable public-key packet sequences may be concatenated to allow
transferring multiple public keys in one operation.

## {11.2} Transferable Secret Keys

OpenPGP users may transfer secret keys.  The format of a transferable
secret key is the same as a transferable public key except that
secret-key and secret-subkey packets are used instead of the public
key and public-subkey packets.  Implementations SHOULD include self-
signatures on any user IDs and subkeys, as this allows for a complete
public key to be automatically extracted from the transferable secret
key.  Implementations MAY choose to omit the self-signatures,
especially if a transferable public key accompanies the transferable
secret key.

## {11.3} OpenPGP Messages

An OpenPGP message is a packet or sequence of packets that corresponds
to the following grammatical rules (comma represents sequential
composition, and vertical bar separates alternatives):

    OpenPGP Message :- Encrypted Message | Signed Message |
                       Literal Message.

    Literal Message :- Literal Data Packet.

    ESK :- Public-Key Encrypted Session Key Packet |
           Symmetric-Key Encrypted Session Key Packet.

    ESK Sequence :- ESK | ESK Sequence, ESK.

    Encrypted Data :- AEAD Encrypted Data Packet

    Encrypted Message :- Encrypted Data | ESK Sequence, Encrypted Data.

    One-Pass Signed Message :- One-Pass Signature Packet,
                OpenPGP Message, Corresponding Signature Packet.

    Signed Message :- Signature Packet, OpenPGP Message |
                      One-Pass Signed Message.

In addition, decrypting a AEAD Encrypted Data packet must yield a
valid OpenPGP Message.

## {11.4} Detached Signatures

Some OpenPGP applications use so-called "detached signatures".  For
example, a program bundle may contain a file, and with it a second
file that is a detached signature of the first file.  These detached
signatures are simply a Signature packet stored separately from the
data for which they are a signature.

# {12} Enhanced Key Formats

## {12.1}  Key Structures

The format of an OpenPGP V5 key that uses multiple public keys is
similar except that the other keys are added to the end as "subkeys"
of the primary key.

    Primary-Key
       [Revocation Self Signature]
       [Direct Key Signature...]
       [User ID [Signature ...] ...]
       [[Subkey [Binding-Signature-Revocation]
               Primary-Key-Binding-Signature] ...]

A subkey always has a single signature after it that is issued using
the primary key to tie the two keys together.  This binding signature
MUST be in V4 format.  Subkeys that can issue signatures MUST have a
V4 binding signature due to the REQUIRED embedded primary key binding
signature.

In the above diagram, if the binding signature of a subkey has been
revoked, the revoked key may be removed, leaving only one key.

In a V5 key, the primary key SHOULD be a key capable of
certification. A primary key capable of making signatures SHOULD be
accompanied by either a certification signature (on a User ID) or a
signature directly on the key.

Implementations SHOULD accept encryption-only primary keys without a
signature.  It also SHOULD allow importing any key accompanied either by
a certification signature or a signature on itself.  It MAY accept
signature-capable primary keys without an accompanying signature.

It is also possible to have a signature-only subkey.  This permits a
primary key that collects certifications (key signatures), but is used
only for certifying subkeys that are used for encryption and
signatures.

## {12.2} Key IDs and Fingerprints

A V5 fingerprint is the 256-bit SHA2-256 hash of the octet 0x99, followed
by the four-octet packet length, followed by the entire Public-Key
packet starting with the version field.  The Key ID is the high-order 64
bits of the fingerprint.  Here are the fields of the hash material,
with the example of a DSA key:

    a.1) 0x9A (1 octet)

    a.2) four-octet scalar octet count of (b)-(f)

    b) version number = 5 (1 octet);

    c) timestamp of key creation (4 octets);

    d) algorithm (1 octet): 17 = DSA (example);

    e) four-octet scalar octet count for the following key material;

    f) algorithm-specific fields.

    Algorithm-Specific Fields for DSA keys (example):

    f.1) MPI of DSA prime p;

    f.2) MPI of DSA group order q (q is a prime divisor of p-1);

    f.3) MPI of DSA group generator g;

    f.4) MPI of DSA public-key value y (= g\*\*x mod p where x is secret).

Note that it is possible for there to be collisions of Key IDs -- two
different keys with the same Key ID.  Note that there is a much
smaller, but still non-zero, probability that two different keys have
the same fingerprint.

Finally, the Key ID and fingerprint of a subkey are calculated in the
same way as for a primary key, including the 0x9A (V5 key) as the
first octet (even though this is not a valid packet ID for a public
subkey).

# Elliptic Curve Cryptography

This section descripes algorithms and parameters used with Elliptic
Curve Cryptography (ECC) keys.  A thorough introduction to ECC can be
found in [](#KOBLITZ).

## Supported ECC Curves

This document references curve "Curve25519", defined in [](#RFC7748)
for use with Ed25519 (EdDSA signing) and X25519 (encryption).

The named curves are referenced as a sequence of bytes in this
document, called throughout, curve OID.  [](#ecc-curve-oid) describes
in detail how this sequence of bytes is formed.

## ECDH Conversion Primitives

This document defines the uncompressed point format for ECDH
and a custom compression format for certain curves. The point is
encoded in the Multiprecision Integer (MPI) format.

For an uncompressed point the content of the MPI is:

    B = 04 || x || y

where x and y are coordinates of the point P = (x, y), each encoded in
the big-endian format and zero-padded to the adjusted underlying field
size.  The adjusted underlying field size is the underlying field size
that is rounded up to the nearest 8-bit boundary.  This encoding is
compatible with the definition given in [](#SEC1).

For a custom compressed point the content of the MPI is:

    B = 40 || x

where x is the x coordinate of the point P encoded to the rules
defined for the specified curve.  This format is used for ECDH keys
based on curves expressed in Montgomery form.

Therefore, the exact size of the MPI payload is 263 for Curve25519.

Even though the zero point, also called the point at infinity, may
occur as a result of arithmetic operations on points of an elliptic
curve, it SHALL NOT appear in data structures defined in this
document.

If other conversion methods are defined in the future, a compliant
application MUST NOT use a new format when in doubt that any recipient
can support it.  Consider, for example, that while both the public key
and the per-recipient ECDH data structure, respectively defined in
Sections 9{FIXME} and 10{FIXME}, contain an encoded point field, the
format changes to the field in Section 10{FIXME} only affect a given
recipient of a given message.

## EdDSA Point Format

The EdDSA algorithm defines a specific point compression format.  To
indicate the use of this compression format and to make sure that the
key can be represented in the Multiprecision Integer (MPI) format the
octet string specifying the point is prefixed with the octet 0x40.
This encoding is an extension of the encoding given in [](#SEC1) which
uses 0x04 to indicate an uncompressed point.

For example, the length of a public key for the curve Ed25519 is 263
bit: 7 bit to represent the 0x40 prefix octet and 32 octets for the
native value of the public key.


## Key Derivation Function

A key derivation function (KDF) is necessary to implement the EC
encryption.  The Concatenation Key Derivation Function (Approved
Alternative 1) [](#SP800-56A) with the KDF hash function that is
SHA2-256 [](#FIPS180) or stronger is REQUIRED.  See Section
12{FIXME} for the details regarding the choice of the hash function.

For convenience, the synopsis of the encoding method is given below
with significant simplifications attributable to the restricted choice
of hash functions in this document.  However, [](#SP800-56A) is the
normative source of the definition.

    //   Implements KDF( X, oBits, Param );
    //   Input: point X = (x,y)
    //   oBits - the desired size of output
    //   hBits - the size of output of hash function Hash
    //   Param - octets representing the parameters
    //   Assumes that oBits <= hBits
    // Convert the point X to the octet string, see section 6{FIXME}:
    //   ZB' = 04 || x || y
    // and extract the x portion from ZB'
    ZB = x;
    MB = Hash ( 00 || 00 || 00 || 01 || ZB || Param );
    return oBits leftmost bits of MB.

Note that ZB in the KDF description above is the compact
representation of X, defined in Section 4.2 of [](#RFC6090).

## EC DH Algorithm (ECDH)

The method is a combination of an ECC Diffie-Hellman method to
establish a shared secret, a key derivation method to process the
shared secret into a derived key, and a key wrapping method that uses
the derived key to protect a session key used to encrypt a message.

The One-Pass Diffie-Hellman method C(1, 1, ECC CDH) [](#SP800-56A)
MUST be implemented with the following restrictions: the ECC CDH
primitive employed by this method is modified to always assume the
cofactor as 1, the KDF specified in Section 7 is used, and the KDF
parameters specified below are used.

The KDF parameters are encoded as a concatenation of the following 5
variable-length and fixed-length fields, compatible with the
definition of the OtherInfo bitstring [](#SP800-56A):

  - a variable-length field containing a curve OID, formatted as
    follows:

      + a one-octet size of the following field

      + the octets representing a curve OID, defined in Section 11

  - a one-octet public key algorithm ID defined in Section 5

  - a variable-length field containing KDF parameters, identical to
    the corresponding field in the ECDH public key, formatted as
    follows:

      + a one-octet size of the following fields; values 0 and 0xff
        are reserved for future extensions

      + a one-octet value 01, reserved for future extensions

      + a one-octet hash function ID used with the KDF

      + a one-octet algorithm ID for the symmetric algorithm used to
        wrap the symmetric key for message encryption; see Section 8
        for details

  - 20 octets representing the UTF-8 encoding of the string
    "Anonymous Sender    ", which is the octet sequence
    41 6E 6F 6E 79 6D 6F 75 73 20 53 65 6E 64 65 72 20 20 20 20

  - 20 octets representing a recipient encryption subkey or a master
    key fingerprint, identifying the key material that is needed for
    the decryption.  For version 5 keys the 20 leftmost octets of the
    fingerprint are used.

The size of the KDF parameters sequence, defined above, is 56 for
Curve25519.

The key wrapping method is described in [](#RFC3394).  KDF produces a
symmetric key that is used as a key-encryption key (KEK) as specified
in [](#RFC3394).  Refer to Section 13{FIXME} for the details regarding the
choice of the KEK algorithm, which SHOULD be one of three AES
algorithms.  Key wrapping and unwrapping is performed with the default
initial value of [](#RFC3394).

The input to the key wrapping method is the value "m" derived from the
session key, as described in Section 5.1{FIXME}, "Public-Key
Encrypted Session Key Packets (Tag 1)", except that the PKCS #1.5
padding step is omitted.  The result is padded using the method
described in [](#PKCS5) to the 8-byte granularity.  For example, the
following AES-256 session key, in which 32 octets are denoted from k0
to k31, is composed to form the following 40 octet sequence:

    09 k0 k1 ... k31 c0 c1 05 05 05 05 05

The octets c0 and c1 above denote the checksum.  This encoding allows
the sender to obfuscate the size of the symmetric encryption key used
to encrypt the data.  For example, assuming that an AES algorithm is
used for the session key, the sender MAY use 5 bytes of padding for
AES-256, respectively, to provide the same number of octets, 40 total,
as an input to the key wrapping method.

The output of the method consists of two fields.  The first field is
the MPI containing the ephemeral key used to establish the shared
secret.  The second field is composed of the following two fields:

  - a one-octet encoding the size in octets of the result of the key
    wrapping method; the value 255 is reserved for future extensions;

  - up to 254 octets representing the result of the key wrapping
    method, applied to the 8-byte padded session key, as described
    above.

Note that for session key sizes 128, 192, and 256 bits, the size of
the result of the key wrapping method is, respectively, 32, 40, and 48
octets, unless the size obfuscation is used.

For convenience, the synopsis of the encoding method is given below;
however, this section, [](#SP800-56A), and [](#RFC3394) are the
normative sources of the definition.

    Obtain the authenticated recipient public key R
    Generate an ephemeral key pair {v, V=vG}
    Compute the shared point S = vR;
    m = symm_alg_ID || session key || checksum || pkcs5_padding;
    curve_OID_len = (byte)len(curve_OID);
    Param = curve_OID_len || curve_OID || public_key_alg_ID || 03
    || 01 || KDF_hash_ID || KEK_alg_ID for AESKeyWrap || "Anonymous
    Sender    " || recipient_fingerprint;
    Z_len = the key size for the KEK_alg_ID used with AESKeyWrap
    Compute Z = KDF( S, Z_len, Param );
    Compute C = AESKeyWrap( Z, m ) as per [RFC3394]
    VB = convert point V to the octet string
    Output (MPI(VB) || len(C) || C).

The decryption is the inverse of the method given.  Note that the
recipient obtains the shared secret by calculating

    S = rV = rvG, where (r,R) is the recipient's key pair.

# {13} Notes on Algorithms

## {13.1}  PKCS\#1 Encoding in OpenPGP

This standard makes use of the PKCS\#1 functions EME-PKCS1-v1\_5 and
EMSA-PKCS1-v1\_5.  However, the calling conventions of these functions
has changed in the past.  To avoid potential confusion and
interoperability problems, we are including local copies in this
document, adapted from those in PKCS\#1 v2.1 [](#RFC3447).  RFC 3447
should be treated as the ultimate authority on PKCS\#1 for OpenPGP.
Nonetheless, we believe that there is value in having a self-
contained document that avoids problems in the future with needed
changes in the conventions.

### {13.1.1} EME-PKCS1-v1\_5-ENCODE

    Input:

    k = the length in octets of the key modulus

    M = message to be encoded, an octet string of length mLen, where mLen
    \<= k - 11

    Output:

    EM = encoded message, an octet string of length k

    Error: "message too long"

     1. Length checking: If mLen > k - 11, output "message too long"
        and stop.

     2. Generate an octet string PS of length k - mLen - 3 consisting
        of pseudo-randomly generated nonzero octets.  The length of PS
        will be at least eight octets.

     3. Concatenate PS, the message M, and other padding to form an
        encoded message EM of length k octets as

        EM = 0x00 || 0x02 || PS || 0x00 || M.

     4. Output EM.

### {13.1.2} EME-PKCS1-v1\_5-DECODE

    Input:

    EM = encoded message, an octet string

    Output:

    M = message, an octet string

    Error: "decryption error"

To decode an EME-PKCS1\_v1\_5 message, separate the encoded message EM
into an octet string PS consisting of nonzero octets and a message M
as follows

     EM = 0x00 || 0x02 || PS || 0x00 || M.

If the first octet of EM does not have hexadecimal value 0x00, if the
second octet of EM does not have hexadecimal value 0x02, if there is
no octet with hexadecimal value 0x00 to separate PS from M, or if the
length of PS is less than 8 octets, output "decryption error" and
stop.  See also the security note in Section 14 regarding differences
in reporting between a decryption error and a padding error.

### {13.1.3} EMSA-PKCS1-v1\_5

This encoding method is deterministic and only has an encoding
operation.

    Option:

    Hash - a hash function in which hLen denotes the length in octets
           of the hash function output

    Input:

    M = message to be encoded

    emLen = intended length in octets of the encoded message, at least
         tLen + 11, where tLen is the octet length of the DER encoding
         T of a certain value computed during the encoding operation

    Output:

    EM = encoded message, an octet string of length emLen

    Errors: "message too long";
            "intended encoded message length too short"

Steps:

     1. Apply the hash function to the message M to produce a hash
        value H:

        H = Hash(M).

        If the hash function outputs "message too long," output
        "message too long" and stop.

     2. Using the list in Section 5.2.2, produce an ASN.1 DER value
        for the hash function used.  Let T be the full hash prefix
        from Section 5.2.2, and let tLen be the length in octets of T.

     3. If emLen < tLen + 11, output "intended encoded message length
        too short" and stop.

     4. Generate an octet string PS consisting of emLen - tLen - 3
        octets with hexadecimal value 0xFF.  The length of PS will be
        at least 8 octets.

     5. Concatenate PS, the hash prefix T, and other padding to form
        the encoded message EM as

            EM = 0x00 || 0x01 || PS || 0x00 || T.

     6. Output EM.

## EdDSA

Although the EdDSA algorithm allows arbitrary data as input, its use
with OpenPGP requires that a digest of the message is used as input
(pre-hashed).  See section XXXXX, "Computing Signatures" for details.
Truncation of the resulting digest is never applied; the resulting
digest value is used verbatim as input to the EdDSA algorithm.

# {14} Security Considerations

  - In late summer 2002, Jallad, Katz, and Schneier published an
    interesting attack on the OpenPGP protocol and some of its
    implementations [JKS02].  In this attack, the attacker modifies a
    message and sends it to a user who then returns the erroneously
    decrypted message to the attacker.  The attacker is thus using the
    user as a random oracle, and can often decrypt the message.

    This attack can be defeated by the use of AEAD Encrypted Data
    Packets. For this, the implementation MUST NOT output
    unauthenticated data.

  - PKCS\#1 has been found to be vulnerable to attacks in which a system
    that reports errors in padding differently from errors in decryption
    becomes a random oracle that can leak the private key in mere
    millions of queries.  Implementations must be aware of this attack
    and prevent it from happening.  The simplest solution is to report a
    single error code for all variants of decryption errors so as not to
    leak information to an attacker.

  - Refer to [](#FIPS186), B.4.1, for the method to generate a
    uniformly distributed ECC private key.

  - Although technically possible, the EdDSA algorithm MUST NOT be
    used with a digest algorithms weaker than SHA2-256.

<!-- eof -->
